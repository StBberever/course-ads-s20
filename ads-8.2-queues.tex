\section{Ретроактивность для конкретных структур данных}
\subsection{Двунаправленная очередь}

Двунаправленная очередь — это структура данных, хранящая некоторые элементы и поддерживающая следующие операции:

\begin{center} \begin{tabular}{ll}
	{\tt update} & $\text{pushL} (x)$: вставить элемент слева \\
		& popL: удалить элемент слева \\
		& $\text{pushR} (x)$: вставить элемент справа \\
		& popR: удалить элемент справа \\
	{\tt query} & Узнать крайний правый, крайний левый элементы
\end{tabular} \end{center}

\begin{theorem} [\cite{demaine2007retroactive}, Теорема 7]
	Двунаправленную очередь можно сделать полно ретроактивной, так что ретро-обновления и ретро-запросы будут занимать время $O \ll \log m \rr$, а запросы о текущем состоянии структуры — $O \ll 1 \rr$.
\end{theorem}

\begin{proof} \item \vspace{-7mm}
\paragraph{Описание структуры данных} Элементы текущей версии очереди будут храниться в массиве $A$. Также нам потребуются числа $L$ и $R$ — индексы левого и правого краёв рабочего участка массива $A$. Если очередь за последние несколько операций становилась короче, то за этими левыми и правыми краями будет оставаться что-то написанное, мы не будем его стирать, но и не будем мыслить его частью очереди.

	В первом приближении понятно, как делать push и pop в настоящий момент времени. Для push слева уменьшим на единицу индекс левого края и запишем на левый край новый элемент (возможно, поверх чего-то старого); для pop слева просто увеличим на единицу индекс края. Справа — симметрично.

	Рассмотрим два списка: $U_L$ и $U_R$. Это отсортированные по времени списки операций, соответственно, с правым и левым краями очереди. У каждой операции в этих списках есть вес: push имеет вес $+1$, pop — $-1$. Заметим, что индекс, например, правого края равен сумме весов всех операций в списке $U_R$.

	Сделаем из $U_L$, $U_R$ сбалансированные деревья поиска: операции будут храниться в листьях, а каждый узел будет хранить сумму весов всех операций его поддерева. Значение $R$ в момент, когда была сделана какая-то операция, можно посчитать, сложив значения, хранимые левыми братьями узлов, в которые мы спускались направо по пути к означенной операции. \vspace{-4mm}

\paragraph{Реализация ретро-операций} При ретро-операции в момент $t$ спустимся к этому моменту времени в соответствующем дереве ($U_L$ или $U_R$) и запишем операцию в новом листе. При этом прибавим вес операции к суммам во всех узлах, через которые мы спускались.

	Чтобы реализовать ретро-запрос, в каждом узле деревьев поиска будем также хранить наибольшее и наименьшее значения префиксных сумм, достигаемых в поддереве этого узла. Эти значения говорят нам, в каких пределах были левый и правый край рабочего участка очереди на соответствующем отрезке времени.

	Дан момент времени $t$, нужно выяснить, где в этот момент находился конец рабочего участка массива и что там было записано. Индекс $i$ конца рабочего участка мы можем посчитать, спустившись по дереву, как описано выше.

	Пусть мы работаем с правым краем очереди. Найдём в $U_R$ последнюю операцию перед моментом времени $t$. Поднимемся из её листа в корень дерева, а затем спустимся обратно, каждый раз выбирая правое поддерево из тех, для которых $i$ находится между наибольшим и наименьшим значениями префиксных сумм, хранящимися в вершине поддерева.

	Такой выбор поддерева гарантирует нам то, что мы попадём в некоторый элемент, хранящийся в нужной нам ячейке массива, при этом данный элемент появился там на нужном нам {\it переписывании} — то есть, он написан поверх элемента, который был на этом месте раньше, чем время $t$, и его ещё не успел сменить элемент, который появится там позже. Действительно, условие «находиться между максимумом и минимумом префиксных сумм» равносильно условию «оставаться в рабочем участке массива, не будучи перезаписанным другим элементом».
\end{proof}

\subsection{Очередь с приоритетом}
\input{priority queue/priorityQueue}
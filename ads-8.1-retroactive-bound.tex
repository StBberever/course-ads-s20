\subsection{Нижняя оценка на создание ретроактивной структуры: word RAM}

\begin{definition}
	{\itshape Модель вычислений} {\scshape cell-probe} — это {\scshape word RAM}, в которой единственной операцией, имеющей цену и учитывающейся при подсчёте времени работы, является доступ к данным. Данные по-прежнему хранятся в блоках фиксированного размера, чтение целого блока имеет единичную стоимость.
\end{definition}

\begin{definition}
	{\itshape Свёртка двух последовательностей слов $\lag x_0 \ldots x_{k-1} \rag$, $\lag y_0 \ldots y_{k-1} \rag$}~— это последовательность слов
     \begin{equation} \label{eq:dynConv}
	\lag w_0 \ldots w_{2k-1} \rag
	\text{,\quad такая, что\quad}
	w_i = \sum\limits_{a+b=i} x_a \times y_b.
     \end{equation}
\end{definition}

\begin{task}[Динамическая свёртка] \label{task:dynConv}
	Требуется поддерживать в памяти набор слов $\lag x_0 \ldots x_{2k-1} \rag$ и эффективно отвечать на следующие запросы:
     \begin{enumerate}
	\item $\text{\tt change}_k (x)$: присвоить $x_k$ значение $x$.
	\item $\text{\tt alg\_quеry}_k$: вернуть $k$-ую компоненту свёртки
	     \begin{equation*}
		\lag x_0 \ldots x_{k-1} \rag \otimes \lag x_{k} \ldots x_{2k-1} \rag.
	     \end{equation*}
     \end{enumerate}
\end{task}

\begin{theorem}[\cite{frandsen1998dynalg}, Теорема 1]
	Задача~\ref{task:dynConv} не решается на моделях {\scshape cell-probe} и {\scshape word RAM} быстрее, чем $\Omega \ll \sqrt{n} \rr$ в худшем случае.
\end{theorem}

\begin{theorem}[\cite{demaine2007retroactive}, Теорема 3]
	Существует структура данных в модели {\scshape word RAM} со словами размера $\log n$, которая поддерживает обновление и запрос за $O(1)$, но любая частично ретроактивная структура данных с теми же функциями требует время
     \begin{equation*}
	\Omega \ll \sqrt{\frac{r}{\log r}} \rr\text{\quad amortised}
     \end{equation*}
	либо на обновление, либо на запрос.
\end{theorem}

\begin{proof}
	Приведём пример такой структуры. Она будет поддерживать набор слов $\lag w_1 \ldots w_m \rag$ линейного размера. Изначально все эти слова нулевые. Будут доступны следующие операции:

\begin{center} \begin{tabular}{ll}
	{\tt update} & $w_i \coloneqq x$ \\
		& $w_i \coloneqq w_j + w_k$ \\
		& $w_i \coloneqq w_j \times w_k$ \\
	{\tt query} & $w_i = \text{?}$
\end{tabular} \end{center}

	Модель вычислений {\scshape word RAM} позволяет делать такие операции за константное время. Над такой структурой данных мы можем за $O(n \log n)$ времени и $O(n)$ памяти сгенерировать и проделать последовательность обновлений, которая посчитает свёртку~\eqref{eq:dynConv} двух половинок хранимого набора слов: это называется быстрое дискретное преобразование Фурье.
	
	Теперь пусть мы хотим делать ретроактивные Insert вида $w_i \coloneqq x$ в начальный момент времени. Понятно, что возможность такой операции равносильна решению Задачи~\ref{task:dynConv} о динамической свёртке, что не может быть сделано быстрее, чем за $\Omega \ll \sqrt{n} \rr$ на каждое изменение.
	
	При этом при вычислении преобразования Фурье было сделано $r = O(n \log n)$ операций. Чтобы выразить время операции через $r$, заметим, что $n = \Omega \ll r / \log r \rr$. Мы получили, что время решения задачи о динамической свёртке —
     \begin{equation*}
	\Omega \ll \sqrt{n} \rr = \Omega \ll \sqrt{\frac{r}{\log r}} \rr.
     \end{equation*}
\end{proof}

\section{От частичной ретроактивности к полной} \noteauthor{Борис Золотов}
\subsection{Пессимистический результат}

\begin{theorem}[\cite{demaine2007retroactive}, Теорема 4]
	Существует структура данных в модели {\scshape cell-probe}, которая поддерживает частично ретроактивные обновления за константу, но при этом любая полно ретроактивная структура с тем же функционалом будет требовать $O(\log n)$ времени для запросов к прошлому (напомним, $m$ — время жизни структуры).
\end{theorem}

\begin{proof}
	Приведём пример такой структуры. Она будет поддерживать набор чисел со следующими операциями:

\begin{center} \begin{tabular}{ll}
	{\tt update} & $\text{insert} (c)$ \\
	{\tt query} & вернуть сумму всех чисел
\end{tabular} \end{center}

	Для частично ретроактивной структуры требуются также следующие операции:

\begin{center} \begin{tabular}{ll}
	$\text{Insert}\, \ll t, \text{«} \text{insert} (c) \text{»}\rr$ \\
	$\text{Delete}\, \ll t \rr$
\end{tabular} \end{center}

	Понятно, что с такими запросами ретроактивные операции можно реализовать за константу: нужно всего лишь либо добавлять к текущей сумме, либо отнимать от неё соответствующее число.
	
	Тем не менее, полно ретроактивная структура данных с таким функционалом умела бы решать задачу о динамической префиксной сумме. Действительно, мы должны уметь вставлять число в любое место массива и считать сумму от самого начала до произвольного момента. Для задачи о динамической префиксной сумме существует нижняя оценка: $\Omega \ll \log n \rr$ за операцию.

\end{proof}

\subsection{Позитивные результаты} \newcommand{\op}{_{\mathrm{op}}}

Сейчас мы приведём общую схему, как из частично ретроактивной структуры данных сделать полно ретроактивную.

\begin{theorem}[\cite{demaine2007retroactive}, Теорема 5]
	Дана частично ретроактивная структура данных в модели {\scshape pointer machine} с константной входящей степенью. Пусть она требует время $T(m)$ на ретроактивное обновление и $Q(m)$ на запросы о её текущем состоянии. Тогда у этой структуры данных существует полно ретроактивная версия со следующими характеристиками: \vspace{-0.33in}

     \begin{align*}
	\text{Время на ретроактивное обновление\quad} & O \ll \sqrt{m} \cdot T(m) \rr, \\
	\text{Время на запрос в произвольный момент\quad} & O \ll \sqrt{m} \cdot T(m) + Q(m) \rr, \\
	\text{Используемая память\quad} & O \ll m \cdot T(m) \rr.
     \end{align*}
\end{theorem}

\begin{proof}
	Будем хранить $\sqrt{m}$ версий структуры данных~— $D_1, D_2, \ldots, D_{\sqrt{m}}$~— равноудалённо раскиданных по временн\'oй оси, отражающей изменения в структуре. Когда приходит запрос о некотором моменте в прошлом, будем брать ближайшую к нему версию $D_i$ и вносить изменения в неё: изменений будет не больше, чем $\sqrt{m}$. Также будем хранить последовательность вносимых изменений.

	\paragraph{Как сделать ретро-изменение.} Пусть мы хотим изменить структуру данных в момент $t$. Найдём ближайший $t_i < t$, для которого мы храним версию $D_i$. Внесём все обновления между моментами времени $t_i$ и $t$, сделаем запрос про настоящее состояние структуры $D_i$, отменим все внесённые обновления.

	\paragraph{Как сделать ретро-обновление.} Внесём обновление, которое хочется сделать в момент времени $t$, во все структуры данных после этого момента.

	\paragraph{Как быть с памятью.} Мы можем сделать структуры $D_i$ полно персистентными, чтобы вносить изменения в их прошлые состояния.  Это увеличивает память и время, необходимые для работы со структурой, в константное число раз, смотреть Раздел~\ref{sec:persist}, пункт~\ref{item:fullPers}.
	
	Собственно, рассмотрим частично ретроактивную структуру данных с полно персистентными $D_i$. Если дана последовательность из $m$ обновлений, мы применим их к изначальной структуре, сохраняя указатели на версии, получаемые после $i \sqrt{m}$ обновлений — это и будут $D_i$. Ретро-обновления создают новую ветку в дереве версий, отходящую от $D_i$.
	
	Каждые $\sqrt{m} / 2$ ретро-обновлений мы будем перестраивать вообще всю структуру данных, чтобы сохранять равномерную распределённость её версий, которые мы храним, и разумное количество изменений между ними. На перестроение требуется $O \ll m \cdot T(m) \rr$ времени — размазав его по $\sqrt(m)$ сделанным операциям, получим $O \ll \sqrt{m} \cdot T(m) \rr$ амортизированно, которое прибавим и ко времени запроса, и ко времени ретро-обновления.
	
	Оценка на память $O \ll m \cdot T(m) \rr$ очевидна — собственно, б\'oльшему объёму памяти в этой задаче неоткуда взяться.
\end{proof}

Если известно, что размер структуры оказывается решительно меньше, чем количество обновлений, которые с ней проделаны, результат может быть улучшен:

\begin{theorem}[\cite{cdgwxy2018retroactive}, Теорема 4]
	Дана частично ретроактивная структура данных в модели {\scshape word RAM}. Пусть её размер — $n$, а также
     \begin{enumerate}
	\item $O(n)$ запросов позволяют полностью восстановить текущее состояние структуры,
	\item Зная текущее состояние структуры, за $O(n)$ операций можно превратить пустую структуру данных в её копию,
	\item Эта структура частично ретроактивная со временем $T\op (n,m)$ на ретроактивные запросы и обновления.
     \end{enumerate}

	Тогда у этой структуры данных существует полно ретроактивная версия с амортизированным временем работы
     \begin{equation*}
	O \ll n \log m \cdot T\op (n,m) \rr.
     \end{equation*}

	Напомним, $n$ — текущий размер структуры, а $m$ — время её жизни, то есть количество проделанных изменений.
\end{theorem}

\begin{proof}
	Очевидно.
\end{proof}
